[< к содержанию](/readme.md)

# git clone

### ***Назначение: создание копии проекта для совместной работы в разных репозиториях***

Если проект уже был настроен в центральном репозитории, для создания его копии чаще всего используется команда ``git clone``. Клонирование, как и команда ``git init``, обычно выполняется один раз. После того как разработчик получил рабочую копию, все операции контроля версий и совместная работа осуществляются уже из локального репозитория.

### ***Совместная работа в разных репозиториях***

Важно понимать, что рабочая копия в Git существенно отличается от рабочей копии, получаемой при загрузке исходного кода из репозитория SVN. В отличие от SVN, в Git нет разницы между рабочими копиями и центральным репозиторием — все они являются полноценными [репозиториями Git](https://bitbucket.org/product/ru/code-repository).

Поэтому совместная работа в Git принципиально отличается от совместной работы в SVN. В SVN работа строится на отношении между центральным репозиторием и рабочей копией, а модель совместной работы в Git основана на взаимодействии между репозиториями. Вместо загрузки рабочей копии в центральный репозиторий SVN в Git вы отправляете коммиты из одного репозитория в другой с помощью команды [push](#) или копируете их в обратном направлении с помощью команды [pull](#).

Вы легко можете задавать особую роль определенным репозиториям Git. Например, обозначив один из репозиториев Git как «центральный», вы можете воспроизвести централизованный рабочий процесс с использованием Git. Однако такой подход требует договоренностей, поскольку он не встроен в саму систему контроля версий

### ${\color{red}Использование:}$

Чаще всего с помощью команды ``git clone`` выбирается существующий репозиторий и создается его клон или копия. Это делается в новом каталоге и в другом месте. Исходный репозиторий может находиться в локальной файловой системе или на удаленном устройстве, к которому можно получить доступ с помощью поддерживаемых протоколов. Команда ``git clone`` копирует существующий репозиторий Git. Она похожа на команду SVN checkout, но имеет некоторые отличия: так, полученная «рабочая копия» представляет собой полноценный репозиторий Git с собственной историей и файлами, полностью обособленный от исходного репозитория.

Для удобства в процессе клонирования автоматически создается удаленный доступ к исходному репозиторию (такое соединение называется origin). Это упрощает взаимодействие с центральным репозиторием. Автоматическое соединение обеспечивается за счет создания ссылок Git на концы удаленных веток в каталоге ``refs/remotes/origin``, а также инициализации переменных конфигурации ``remote.origin.url`` и ``remote.origin.fetch``.

Применение команды ``git clone`` демонстрируется на примере в руководстве по настройке репозитория. Ниже показано, как можно получить локальную копию центрального репозитория. Он расположен на сервере по адресу ``example.com``, к которому можно подключиться по протоколу SSH, используя имя пользователя john:

```
git clone ssh://john@example.com/path/to/my-project.git 
cd my-project 
# Start working on the project
```

Первая команда инициализирует новый репозиторий Git в каталоге ``my-project`` на локальной машине и наполняет его содержимым центрального репозитория. Теперь вы можете перейти в проект и приступить к редактированию файлов, созданию снимков состояния и взаимодействию с другими репозиториями. Обратите внимание, что расширение ``.git`` у клонированного репозитория отсутствует. Это означает, что у локальной копии есть рабочий каталог.

### ***Клонирование в конкретную папку***

```
git clone <repo> <directory>
```

Клонирование репозитория из  в директорию ``~!`` на локальной машине.

### ***Клонирование конкретного тега***

```
git clone --branch <tag> <repo>
```

Клонирование репозитория из  и клонирование только ссылки на .

### ***Поверхностное клонирование***

```
git clone -depth=1 <repo>
```

Эта команда клонирует репозиторий, расположенный в , при этом количество коммитов в копируемой истории определяется опцией depth=1. В примере создается клон , и в него включается только последний коммит. Поверхностное клонирование особенно эффективно, когда вы работаете с репозиториями с объемной историей коммитов. Объемная история коммитов может привести к появлению проблем с масштабированием в виде ограничений на использование дискового пространства и чрезмерной продолжительности операции клонирования. Поверхностное клонирование помогает устранить эти проблемы.


[< к содержанию](/readme.md)

